package lang.lexer;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.Stack;

import lang.token.Token;
import lang.token.TokenPosition;
import lang.token.TokenType;
import lang.token.Keywords;
import lang.lexer.debug.DebugEvent;
import lang.lexer.debug.LexerDebugger;

/**
 * üîç Lexer - The Text Scanner üîç
 * 
 * This class breaks down source code text into meaningful tokens (words,
 * symbols, numbers).
 * Think of it as a smart text reader that understands programming languages!
 * üìñ‚ú®
 */
public final class Lexer {

    private Stack<LineColumn> positionHistory;
    private final String input;
    private int currentPosition;
    private int nextPosition;
    private char currentCharacter = ' ';
    private LineColumn lineColumn;

    private static final char EOF = '\0';

    private final LexerDebugger debugger;

    /**
     * üìç LineColumn - Position Tracker üìç
     * 
     * Keeps track of where we are in the text file (line and column numbers).
     * Like GPS coordinates for your code! üó∫Ô∏è
     */
    private static record LineColumn(int line, int column) {
    }

    public Lexer(String input) {
        this(input, null);
    }

    /**
     * üöÄ Creates a new Lexer with optional debug support
     * 
     * @param input    The source code to tokenize
     * @param debugger Optional debugger (null to disable debugging)
     */
    public Lexer(String input, LexerDebugger debugger) {
        this.input = input;
        this.debugger = debugger;
        this.lineColumn = new LineColumn(1, 0);
        this.positionHistory = new Stack<>();

        if (isDebugging()) {
            this.debugger.onSessionStart(input);
        }

        this.advanceToNextCharacter();
    }

    private boolean isDebugging() {
        return this.debugger != null;
    }

    /**
     * üëÄ Gets the character we're currently looking at
     * 
     * @return The current character under our "reading cursor" üî§
     */
    public char getCurrentChar() {
        return this.currentCharacter;
    }

    /**
     * üîÑ Resets the lexer to start reading from the beginning
     * 
     */
    public void reset() {
        this.currentPosition = 0;
        this.nextPosition = 0;
        this.currentCharacter = EOF;
        this.lineColumn = new LineColumn(1, 0);
        this.advanceToNextCharacter();
        this.positionHistory.clear();

        if (isDebugging()) {
            this.debugger.onSessionReset();
        }

        this.advanceToNextCharacter();
    }

    /**
     * üéØ Reads and returns the next meaningful token from the text
     * 
     * This is the main method! It identifies what type of "word" or symbol
     * comes next in the code (like numbers, keywords, operators, etc.) üîç‚ú®
     * 
     * @return A Token object containing the type and value of what was found üé´
     */
    public Token nextToken() {

        int preTokenPosition = this.currentPosition;
        char triggerChar = this.currentCharacter;

        Token token;
        this.skipWhitespace();
        this.skipComments();

        switch (this.currentCharacter) {
            case '=':
                token = parseTwoCharacterOperator(TokenType.EQ, TokenType.ASSIGN);
                break;

            case '!':
                token = this.parseTwoCharacterOperator(TokenType.NOT_EQ, TokenType.BANG);
                break;

            case ';':
                token = this.createToken(TokenType.SEMICOLON, this.currentCharacter);
                break;

            case '(':
                token = this.createToken(TokenType.LPAREN, this.currentCharacter);
                break;

            case ')':
                token = this.createToken(TokenType.RPAREN, this.currentCharacter);
                break;

            case ',':
                token = this.createToken(TokenType.COMMA, this.currentCharacter);
                break;

            case '+':
                token = this.parseTwoCharacterOperator(TokenType.PLUS_ASSIGN, TokenType.PLUS);
                break;

            case '-':
                token = this.parseTwoCharacterOperator(
                        TokenType.MINUS_ASSIGN,
                        TokenType.MINUS);
                break;

            case '*':
                token = this.parseTwoCharacterOperator(
                        TokenType.ASTERISK_ASSIGN,
                        TokenType.ASTERISK);
                break;

            case '/':
                token = this.parseTwoCharacterOperator(
                        TokenType.SLASH_ASSIGN,
                        TokenType.SLASH);
                break;

            case '%':
                token = this.createToken(TokenType.MODULUS, this.currentCharacter);
                break;

            case '&':
                token = this.parseTwoCharacterOperator(
                        TokenType.AND,
                        TokenType.BITWISE_AND,
                        '&');
                break;

            case '|':
                token = this.parseTwoCharacterOperator(
                        TokenType.OR,
                        TokenType.BITWISE_OR,
                        '|');
                break;

            case '^':
                token = this.createToken(TokenType.BITWISE_XOR, this.currentCharacter);
                break;

            case '~':
                token = this.createToken(TokenType.BITWISE_NOT, this.currentCharacter);
                break;

            case '<':
                token = this.parseTwoCharacterOperator(
                        TokenType.LESS_THAN_OR_EQUAL,
                        TokenType.LESS_THAN);
                break;

            case '>':
                token = this.parseTwoCharacterOperator(
                        TokenType.GREATER_THAN_OR_EQUAL,
                        TokenType.GREATER_THAN);
                break;

            case '{':
                token = this.createToken(TokenType.LBRACE, this.currentCharacter);
                break;

            case '}':
                token = this.createToken(TokenType.RBRACE, this.currentCharacter);
                break;

            case '[':
                token = this.createToken(TokenType.LBRACKET, this.currentCharacter);
                break;

            case ']':
                token = this.createToken(TokenType.RBRACKET, this.currentCharacter);
                break;

            case ':':
                token = this.createToken(TokenType.COLON, this.currentCharacter);
                break;

            case '.':
                token = this.createToken(TokenType.DOT, currentCharacter);
                break;

            case '"':
                token = this.createToken(TokenType.STRING, readString());
                break;

            case EOF:
                token = this.createToken(TokenType.EOF, "");
                break;

            default:
                token = this.parseIdentifierOrNumber();
                break;
        }

        if (isDebugging()) {
            DebugEvent event = new DebugEvent(
                    token,
                    preTokenPosition,
                    triggerChar,
                    currentPosition,
                    System.nanoTime());
            this.debugger.onTokenCreated(event);
        }

        advanceToNextCharacter();
        return token;
    }

    /**
     * üèÅ Ends the tokenization session
     * Call this when finished tokenizing to get debug summaries
     */
    public void endSession() {
        if (isDebugging()) {
            this.debugger.onSessionEnd();
        }
    }

    /**
     * üî§ Checks if a character is a letter or underscore
     * 
     * Determines if the character can start or be part of a variable name.
     * Letters (A-Z, a-z) and underscore (_) are allowed! ‚úÖ
     * 
     * @param ch The character to examine üîç
     * @return True if it's a letter or underscore, false otherwise ‚úÖ‚ùå
     */
    private final static boolean isLetter(char ch) {
        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || ch == '_';
    }

    /**
     * üî¢ Checks if a character is a digit (0-9)
     * 
     * Perfect for identifying numbers in the source code! üéØ
     * 
     * @param ch The character to check üîç
     * @return True if it's a digit, false otherwise ‚úÖ‚ùå
     */
    private final static boolean isDigit(char ch) {
        return ch >= '0' && ch <= '9';
    }

    /**
     * üö´ Checks if we've reached the end of the input text
     * 
     * Like checking if you've finished reading a book! üìñ‚úã
     * 
     * @return True if we're past the end, false if there's more to read ‚úÖ‚ùå
     */
    private boolean isAtEnd() {
        return this.nextPosition >= this.input.length();
    }

    /**
     * ‚û°Ô∏è Moves our reading position forward by one step
     * 
     * Updates position counters and line/column tracking.
     * Like moving your finger to the next character! üëÜüìñ
     */
    private void advancePosition() {
        this.currentPosition = this.nextPosition;
        this.nextPosition++;

        int line = this.lineColumn.line();
        int column = this.lineColumn.column();

        this.positionHistory.push(new LineColumn(line, column));

        if (this.currentPosition >= this.input.length())
            return;

        if (this.currentCharacter == '\n' || (this.currentCharacter == '\r' && peekNextCharacter() != '\n'))
            this.lineColumn = new LineColumn(line + 1, 0);
        else
            this.lineColumn = new LineColumn(line, column + 1);
    }

    /**
     * üìñ Reads the character at our current position
     * 
     * Gets the next character from the input and advances our position.
     * Like reading the next letter in a book! üî§‚û°Ô∏è
     */
    private void advanceToNextCharacter() {
        this.currentCharacter = this.isAtEnd() ? EOF : this.input.charAt(this.nextPosition);
        this.advancePosition();
    }

    /**
     * üé´ Creates a new Token with position information
     * 
     * Packages up a piece of code (like a keyword or symbol) with its location.
     * Think of it as putting a label on something you found! üè∑Ô∏è
     * 
     * @param type    What kind of token this is (keyword, operator, etc.) üè∑Ô∏è
     * @param literal The actual text value üìù
     * @return A complete Token object with position info üé´
     */
    private Token createToken(TokenType type, String literal) {
        int line = this.lineColumn.line();
        int column = this.lineColumn.column();

        return new Token(type, literal, new TokenPosition(line, column));
    }

    /**
     * üé´ Creates a Token from a single character
     * 
     * Convenience method for single-character tokens like '+', '-', etc.
     * Just converts the character to a string first! üî§‚û°Ô∏èüìù
     * 
     * @param type    The token type üè∑Ô∏è
     * @param literal Single character value üî§
     * @return A Token object üé´
     */
    private Token createToken(TokenType type, char literal) {
        return this.createToken(type, String.valueOf(literal));
    }

    /**
     * üëÄ Looks at the next character without moving forward
     * 
     * Like peeking at the next page of a book without turning it.
     * Useful for checking two-character operators like "==" or "!=" üîçüëÄ
     * 
     * @return The next character, or null character if at end üî§
     */
    private char peekNextCharacter() {
        return this.isAtEnd() ? '\0' : this.input.charAt(this.nextPosition);
    }

    /**
     * üìú Reads a complete string literal from the input
     * 
     * Handles quoted strings with escape sequences like "\n", "\t".
     * Reads everything between the quote marks! "like this" üìù‚ú®
     * 
     * @return The string content (without the surrounding quotes) üìú
     * @throws RuntimeException if string is not properly closed üö´
     */
    private String readString() {
        StringBuilder sb = new StringBuilder();

        while (true) {
            this.advanceToNextCharacter();

            if (this.currentCharacter == '\0')
                throw new RuntimeException("Unterminated string");

            if (this.currentCharacter == '"')
                break;

            if (this.currentCharacter == '\\') {
                this.advanceToNextCharacter();
                sb.append(this.handleEscapeSequence());
                continue;
            }

            sb.append(this.currentCharacter);
        }

        return sb.toString();
    }

    /**
     * üîÄ Handles escape sequences in strings
     * 
     * Converts special sequences like "\n" into actual newlines.
     * Like translating secret codes into real characters! üîìüìù
     * 
     * @return The actual character represented by the escape sequence üî§
     */
    private String handleEscapeSequence() {
        switch (this.currentCharacter) {
            case 'n':
                return "\n";
            case 't':
                return "\t";
            case 'r':
                return "\r";
            case 'f':
                return "\f";
            case 'b':
                return "\b";
            case '\'':
                return "\'";
            case '"':
                return "\"";
            default:
                return String.valueOf(this.currentCharacter);
        }
    }

    /**
     * ‚ö™ Skips over whitespace characters
     * 
     * Jumps past spaces, tabs, newlines - all the "empty" characters
     * that don't matter for code meaning. Like ignoring blank spaces! ü¶ò‚ö™
     */
    private void skipWhitespace() {
        Set<Character> whitespaceCharacters = Set.of(' ', '\t', '\n', '\r', '\f');
        while (whitespaceCharacters.contains(this.currentCharacter)) {
            this.advanceToNextCharacter();
        }
    }

    /**
     * üîç Handles two-character operators (like == or !=)
     * 
     * Checks if the current character plus the next one form a special operator.
     * If not, treats it as a single character. Smart pattern matching! üéØüîç
     * 
     * @param tokenTypeIfDouble Token type if it's a two-character operator üé´
     * @param defaultTokenType  Token type if it's just one character üé´
     * @param peekChar          The character to look for next üëÄ
     * @return The appropriate token üé´
     */
    private Token parseTwoCharacterOperator(TokenType tokenTypeIfDouble, TokenType defaultTokenType, char peekChar) {

        char currChar = this.currentCharacter;
        if (this.peekNextCharacter() == peekChar) {
            this.advanceToNextCharacter();
            return this.createToken(tokenTypeIfDouble, String.format("%c%c", currChar, peekChar));
        }

        return this.createToken(defaultTokenType, this.currentCharacter);
    }

    /**
     * üîç Handles assignment operators (like +=, -=, *=)
     * 
     * Checks if an operator is followed by '=' to make it an assignment.
     * Like checking if '+' becomes '+='! ‚ûï‚û°Ô∏è‚ûïüü∞
     * 
     * @param tokenTypeIfDouble Token type for assignment version üé´
     * @param defaultTokenType  Token type for basic operator üé´
     * @return The appropriate token üé´
     */
    private Token parseTwoCharacterOperator(TokenType tokenTypeIfDouble, TokenType defaultTokenType) {
        return this.parseTwoCharacterOperator(tokenTypeIfDouble, defaultTokenType, '=');
    }

    private void skipComments() {
        while (true) {
            this.skipWhitespace();

            if (this.currentCharacter == '/' && this.peekNextCharacter() == '/') {
                this.skipSingleLineComment();
            } else if (this.currentCharacter == '/' && this.peekNextCharacter() == '*') {
                this.skipMultiLineComment();
            } else {
                break;
            }
        }
    }

    /**
     * üí¨ Skips a single-line comment (//)
     * 
     * Reads and ignores everything until the end of the line.
     * Like skipping a side note in a book! üìù‚û°Ô∏èüóëÔ∏è
     */
    private void skipSingleLineComment() {
        while (this.currentCharacter != '\n' && this.currentCharacter != EOF) {
            this.advanceToNextCharacter();
        }
    }

    private void skipMultiLineComment() {
        this.advanceToNextCharacter(); // skip the '/'
        this.advanceToNextCharacter(); // skip the '*'

        int depth = 1;

        while (depth > 0 && this.currentCharacter != EOF) {
            if (this.currentCharacter == '/' && this.peekNextCharacter() == '*') {
                depth++;
                this.advanceToNextCharacter();
                this.advanceToNextCharacter();
            } else if (this.currentCharacter == '*' && this.peekNextCharacter() == '/') {
                depth--;
                this.advanceToNextCharacter();
                this.advanceToNextCharacter();
            } else {
                this.advanceToNextCharacter();
            }
        }

    }

    /**
     * üî§ Reads a complete identifier (variable/function name)
     * 
     * Collects letters, numbers, and underscores that form a name.
     * Like reading a word letter by letter! üî§üìù
     * 
     * @return The complete identifier string üìù
     */
    private String readIdentifier() {
        int position = this.currentPosition;

        while (Lexer.isLetter(this.currentCharacter) || Lexer.isDigit(this.currentCharacter)) {
            this.advanceToNextCharacter();
        }

        String identifier = this.input.substring(position, this.currentPosition);
        this.backtrack(1);
        return identifier;
    }

    /**
     * ‚¨ÖÔ∏è Moves the reading position backward
     * 
     * Sometimes we need to "un-read" characters we went too far.
     * Like taking a step back! üë£‚¨ÖÔ∏è
     * 
     * @param steps Number of positions to move backward üî¢
     */
    private void backtrack(int steps) {
        this.currentPosition -= steps;
        this.nextPosition -= steps;
        this.currentCharacter = this.input.charAt(this.currentPosition);

        for (int i = 0; i < steps; i++) {
            LineColumn position = this.positionHistory.pop();
            this.lineColumn = position;
        }
    }

    /**
     * üî¢ Reads a complete number from the input
     * 
     * Collects consecutive digits to form a number.
     * Like counting digit by digit! 1Ô∏è‚É£2Ô∏è‚É£3Ô∏è‚É£
     * 
     * @return The complete number as a string üìùüî¢
     */
    private String readNumber() {
        int startPosition = this.currentPosition;

        while (Lexer.isDigit(this.currentCharacter)) {
            this.advanceToNextCharacter();
        }

        String number = this.input.substring(startPosition, this.currentPosition);
        this.backtrack(1);
        return number;
    }

    /**
     * üéØ Identifies and handles identifiers and numbers
     * 
     * Determines if we're looking at a variable name, keyword, or number.
     * The detective work of figuring out what something is! üïµÔ∏è‚Äç‚ôÇÔ∏èüîç
     * 
     * @return A token representing what was identified üé´
     */
    private Token parseIdentifierOrNumber() {
        if (Lexer.isLetter(this.currentCharacter)) {
            String identifier = this.readIdentifier();
            TokenType type = Keywords.lookupIdentifier(identifier);
            return this.createToken(type, identifier);
        } else if (Lexer.isDigit(this.currentCharacter)) {
            String number = this.readNumber();
            return this.createToken(TokenType.INT, number);
        }

        return this.createToken(TokenType.ILLEGAL, this.currentCharacter);
    }

    public List<Token> getTokenStream() {
        List<Token> tokens = new ArrayList<>();
        while (!this.isAtEnd()) {
            tokens.add(this.nextToken());
        }
        reset();
        endSession();
        return tokens;
    }

}

class EOFException extends RuntimeException {
    public EOFException() {
        super("EOF");
    }
}