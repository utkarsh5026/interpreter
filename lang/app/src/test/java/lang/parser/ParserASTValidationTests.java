package lang.parser;

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import lang.lexer.Lexer;
import lang.ast.statements.*;
import lang.ast.base.*;
import lang.ast.expressions.*;
import lang.ast.literals.*;
import lang.ast.utils.AstValidator;
import lang.ast.visitor.AstVisitor;
import lang.token.TokenPosition;

/**
 * 🌳 Comprehensive AST Validation Tests 🌳
 * 
 * This test suite validates the structural integrity and correctness of
 * Abstract Syntax Trees generated by the parser from first principles:
 * 
 * Core Validation Principles:
 * 1. 📊 Structure Validation: Nodes have correct types and relationships
 * 2. 📍 Position Tracking: All nodes have accurate source positions
 * 3. 🔗 Reference Integrity: Parent-child relationships are consistent
 * 4. 💾 Immutability: AST nodes are immutable after creation
 * 5. 🎯 Type Safety: Node types match their semantic meaning
 * 6. 🌐 Visitor Pattern: All nodes support the visitor pattern correctly
 * 7. 📝 String Representation: All nodes have meaningful toString() outputs
 * 
 * Testing Philosophy:
 * - Every AST node type is thoroughly validated
 * - Structural relationships are verified at multiple levels
 * - Edge cases and boundary conditions are tested
 * - The AST accurately represents the source code semantics
 */
@DisplayName("Parser AST Validation Tests")
public class ParserASTValidationTests {

    private LanguageParser parser;

    /**
     * 🎯 Simple visitor implementation for testing the visitor pattern
     */
    private static class TestVisitor implements AstVisitor<String> {
        @Override
        public String visitProgram(Program program) {
            return "Program[" + program.getStatements().size() + " statements]";
        }

        @Override
        public String visitLetStatement(LetStatement letStatement) {
            return "LetStatement[" + letStatement.getName().getValue() + "]";
        }

        @Override
        public String visitConstStatement(ConstStatement constStatement) {
            return "ConstStatement[" + constStatement.getName().getValue() + "]";
        }

        @Override
        public String visitReturnStatement(ReturnStatement returnStatement) {
            return "ReturnStatement[]";
        }

        @Override
        public String visitExpressionStatement(ExpressionStatement expressionStatement) {
            return "ExpressionStatement[]";
        }

        @Override
        public String visitBlockStatement(BlockStatement blockStatement) {
            return "BlockStatement[" + blockStatement.getStatements().size() + " statements]";
        }

        @Override
        public String visitWhileStatement(WhileStatement whileStatement) {
            return "WhileStatement[]";
        }

        @Override
        public String visitForStatement(ForStatement forStatement) {
            return "ForStatement[]";
        }

        @Override
        public String visitBreakStatement(BreakStatement breakStatement) {
            return "BreakStatement[]";
        }

        @Override
        public String visitContinueStatement(ContinueStatement continueStatement) {
            return "ContinueStatement[]";
        }

        @Override
        public String visitIdentifier(Identifier identifier) {
            return "Identifier[" + identifier.getValue() + "]";
        }

        @Override
        public String visitInfixExpression(InfixExpression infixExpression) {
            return "InfixExpression[" + infixExpression.getOperator() + "]";
        }

        @Override
        public String visitPrefixExpression(PrefixExpression prefixExpression) {
            return "PrefixExpression[" + prefixExpression.getOperator() + "]";
        }

        @Override
        public String visitBooleanExpression(BooleanExpression booleanExpression) {
            return "BooleanExpression[" + booleanExpression.getValue() + "]";
        }

        @Override
        public String visitIfExpression(IfExpression ifExpression) {
            return "IfExpression[" + ifExpression.getConditions().size() + " conditions]";
        }

        @Override
        public String visitCallExpression(CallExpression callExpression) {
            return "CallExpression[" + callExpression.getArguments().size() + " args]";
        }

        @Override
        public String visitIndexExpression(IndexExpression indexExpression) {
            return "IndexExpression[]";
        }

        @Override
        public String visitAssignmentExpression(AssignmentExpression assignmentExpression) {
            return "AssignmentExpression[" + assignmentExpression.getName().getValue() + "]";
        }

        @Override
        public String visitIntegerLiteral(IntegerLiteral integerLiteral) {
            return "IntegerLiteral[" + integerLiteral.getValue() + "]";
        }

        @Override
        public String visitStringLiteral(StringLiteral stringLiteral) {
            return "StringLiteral[" + stringLiteral.getValue() + "]";
        }

        @Override
        public String visitArrayLiteral(ArrayLiteral arrayLiteral) {
            return "ArrayLiteral[" + arrayLiteral.getElements().size() + " elements]";
        }

        @Override
        public String visitHashLiteral(HashLiteral hashLiteral) {
            return "HashLiteral[" + hashLiteral.getPairs().size() + " pairs]";
        }

        @Override
        public String visitFunctionLiteral(FunctionLiteral functionLiteral) {
            return "FunctionLiteral[" + functionLiteral.getParameters().size() + " params]";
        }

        @Override
        public String visitFStringLiteral(FStringLiteral fStringLiteral) {
            return "FStringLiteral[" + fStringLiteral.getActualStrings().toString() + "]";
        }

        @Override
        public String visitNullExpression(NullExpression nullExpression) {
            return "NullExpression[]";
        }
    }

    @BeforeEach
    void setUp() {
        // Fresh parser for each test
    }

    /**
     * 🔍 Helper method to parse and validate basic structure
     */
    private Program parseAndValidateProgram(String input) {
        parser = new LanguageParser(new Lexer(input));
        Program program = parser.parseProgram();

        assertFalse(parser.hasErrors(), "Program should parse without errors: " + input);
        assertNotNull(program, "Program should not be null");

        return program;
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 📊 BASIC NODE STRUCTURE VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("🌳 Program node structure validation")
    void testProgramNodeStructure() {
        String input = """
                let x = 5;
                let y = 10;
                return x + y;
                """;

        Program program = parseAndValidateProgram(input);

        // Validate Program structure
        assertEquals(3, program.getStatements().size(), "Program should have 3 statements");
        assertNotNull(program.tokenLiteral(), "Program should have token literal");
        assertNotNull(program.toString(), "Program should have string representation");
        assertNotNull(program.position(), "Program should have position");

        // Validate Program position (should be position of first statement)
        TokenPosition programPos = program.position();
        assertTrue(programPos.line() >= 1, "Program line should be >= 1");
        assertTrue(programPos.column() >= 1, "Program column should be >= 1");

        // Verify Program toString() creates readable output
        String programString = program.toString();
        assertFalse(programString.trim().isEmpty(), "Program string should not be empty");
        assertTrue(programString.contains("let"), "Program string should contain 'let'");
        assertTrue(programString.contains("return"), "Program string should contain 'return'");

        // Validate each statement is not null and has proper structure
        for (Statement stmt : program.getStatements()) {
            assertNotNull(stmt, "Statement should not be null");
            assertNotNull(stmt.tokenLiteral(), "Statement should have token literal");
            assertNotNull(stmt.toString(), "Statement should have string representation");
            assertNotNull(stmt.position(), "Statement should have position");
        }
    }

    @Test
    @DisplayName("🌳 Let statement node structure validation")
    void testLetStatementNodeStructure() {
        String input = "let variableName = 42;";
        Program program = parseAndValidateProgram(input);

        assertEquals(1, program.getStatements().size());
        Statement stmt = program.getStatements().get(0);

        // Validate statement type
        assertTrue(AstValidator.isLetStatement(stmt), "Statement should be LetStatement");
        LetStatement letStmt = (LetStatement) stmt;

        // Validate token literal
        assertEquals("let", letStmt.tokenLiteral(), "Token literal should be 'let'");

        // Validate identifier
        Identifier name = letStmt.getName();
        assertNotNull(name, "Name should not be null");
        assertEquals("variableName", name.getValue(), "Variable name should be 'variableName'");
        assertNotNull(name.tokenLiteral(), "Name should have token literal");
        assertNotNull(name.toString(), "Name should have string representation");
        assertNotNull(name.position(), "Name should have position");

        // Validate value expression
        Expression value = letStmt.getValue();
        assertNotNull(value, "Value should not be null");
        assertTrue(AstValidator.isIntegerLiteral(value), "Value should be IntegerLiteral");

        IntegerLiteral intVal = (IntegerLiteral) value;
        assertEquals(42, intVal.getValue(), "Integer value should be 42");
        assertEquals("42", intVal.tokenLiteral(), "Integer token literal should be '42'");
        assertEquals("42", intVal.toString(), "Integer string should be '42'");

        // Validate position information
        TokenPosition letPos = letStmt.position();
        TokenPosition namePos = name.position();
        TokenPosition valuePos = value.position();

        assertNotNull(letPos, "Let statement position should not be null");
        assertNotNull(namePos, "Name position should not be null");
        assertNotNull(valuePos, "Value position should not be null");

        // Position should be reasonable (not negative or zero for line)
        assertTrue(letPos.line() >= 1, "Let position line should be >= 1");
        assertTrue(namePos.line() >= 1, "Name position line should be >= 1");
        assertTrue(valuePos.line() >= 1, "Value position line should be >= 1");

        assertTrue(letPos.column() >= 0, "Let position column should be >= 0");
        assertTrue(namePos.column() >= 0, "Name position column should be >= 0");
        assertTrue(valuePos.column() >= 0, "Value position column should be >= 0");
    }

    @Test
    @DisplayName("🌳 Infix expression node structure validation")
    void testInfixExpressionNodeStructure() {
        String input = "5 + 3 * 2;";
        Program program = parseAndValidateProgram(input);

        assertEquals(1, program.getStatements().size());
        ExpressionStatement exprStmt = (ExpressionStatement) program.getStatements().get(0);

        // Should be: 5 + (3 * 2)
        Expression expr = exprStmt.getExpression();
        assertTrue(AstValidator.isInfixExpression(expr), "Expression should be InfixExpression");

        InfixExpression addExpr = (InfixExpression) expr;
        assertEquals("+", addExpr.getOperator(), "Operator should be '+'");

        // Validate left operand
        Expression left = addExpr.getLeft();
        assertNotNull(left, "Left operand should not be null");
        assertTrue(AstValidator.isIntegerLiteral(left), "Left should be IntegerLiteral");
        IntegerLiteral leftInt = (IntegerLiteral) left;
        assertEquals(5, leftInt.getValue(), "Left value should be 5");

        // Validate right operand (should be multiplication)
        Expression right = addExpr.getRight();
        assertNotNull(right, "Right operand should not be null");
        assertTrue(AstValidator.isInfixExpression(right), "Right should be InfixExpression");
        InfixExpression multExpr = (InfixExpression) right;
        assertEquals("*", multExpr.getOperator(), "Right operator should be '*'");

        // Validate multiplication operands
        assertTrue(AstValidator.isIntegerLiteral(multExpr.getLeft()), "Mult left should be IntegerLiteral");
        assertTrue(AstValidator.isIntegerLiteral(multExpr.getRight()), "Mult right should be IntegerLiteral");

        IntegerLiteral multLeft = (IntegerLiteral) multExpr.getLeft();
        IntegerLiteral multRight = (IntegerLiteral) multExpr.getRight();
        assertEquals(3, multLeft.getValue(), "Mult left value should be 3");
        assertEquals(2, multRight.getValue(), "Mult right value should be 2");

        // Validate string representation
        String exprString = addExpr.toString();
        assertNotNull(exprString, "Expression string should not be null");
        assertFalse(exprString.trim().isEmpty(), "Expression string should not be empty");
        assertTrue(exprString.contains("+"), "Expression string should contain '+'");
        assertTrue(exprString.contains("*"), "Expression string should contain '*'");

        // Validate all nodes have positions
        assertNotNull(addExpr.position(), "Add expression should have position");
        assertNotNull(left.position(), "Left operand should have position");
        assertNotNull(right.position(), "Right operand should have position");
        assertNotNull(multExpr.position(), "Mult expression should have position");
        assertNotNull(multLeft.position(), "Mult left should have position");
        assertNotNull(multRight.position(), "Mult right should have position");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 🎯 VISITOR PATTERN VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("🎯 Visitor pattern works for all node types")
    void testVisitorPatternSupport() {
        String input = """
                let x = 5;
                const PI = 3;
                return x + PI;
                """;

        Program program = parseAndValidateProgram(input);
        TestVisitor visitor = new TestVisitor();

        // Validate visitor works on Program
        String programResult = program.accept(visitor);
        assertNotNull(programResult, "Program visitor result should not be null");
        assertTrue(programResult.contains("Program"), "Result should contain 'Program'");
        assertTrue(programResult.contains("3 statements"), "Result should mention statement count");

        // Validate visitor works on each statement
        for (Statement stmt : program.getStatements()) {
            String stmtResult = stmt.accept(visitor);
            assertNotNull(stmtResult, "Statement visitor result should not be null");
            assertFalse(stmtResult.trim().isEmpty(), "Statement result should not be empty");
        }

        // Test specific statement types
        LetStatement letStmt = (LetStatement) program.getStatements().get(0);
        String letResult = letStmt.accept(visitor);
        assertTrue(letResult.contains("LetStatement"), "Let result should contain 'LetStatement'");
        assertTrue(letResult.contains("x"), "Let result should contain variable name");

        ConstStatement constStmt = (ConstStatement) program.getStatements().get(1);
        String constResult = constStmt.accept(visitor);
        assertTrue(constResult.contains("ConstStatement"), "Const result should contain 'ConstStatement'");
        assertTrue(constResult.contains("PI"), "Const result should contain constant name");

        ReturnStatement returnStmt = (ReturnStatement) program.getStatements().get(2);
        String returnResult = returnStmt.accept(visitor);
        assertTrue(returnResult.contains("ReturnStatement"), "Return result should contain 'ReturnStatement'");
    }

    @Test
    @DisplayName("🎯 Visitor pattern works for complex expressions")
    void testVisitorPatternComplexExpressions() {
        String input = """
                let result = func(x + 1, arr[i]) * 2;
                """;

        Program program = parseAndValidateProgram(input);
        TestVisitor visitor = new TestVisitor();

        LetStatement letStmt = (LetStatement) program.getStatements().get(0);
        Expression value = letStmt.getValue();

        // Value should be: func(x + 1, arr[i]) * 2
        assertTrue(AstValidator.isInfixExpression(value), "Value should be InfixExpression");
        InfixExpression multExpr = (InfixExpression) value;

        String multResult = multExpr.accept(visitor);
        assertTrue(multResult.contains("InfixExpression"), "Mult result should contain 'InfixExpression'");
        assertTrue(multResult.contains("*"), "Mult result should contain operator");

        // Left side should be function call
        Expression left = multExpr.getLeft();
        assertTrue(AstValidator.isCallExpression(left), "Left should be CallExpression");
        CallExpression callExpr = (CallExpression) left;

        String callResult = callExpr.accept(visitor);
        assertTrue(callResult.contains("CallExpression"), "Call result should contain 'CallExpression'");
        assertTrue(callResult.contains("2 args"), "Call result should mention argument count");

        // Test arguments
        assertEquals(2, callExpr.getArguments().size(), "Should have 2 arguments");

        Expression arg1 = callExpr.getArguments().get(0);
        assertTrue(AstValidator.isInfixExpression(arg1), "Arg1 should be InfixExpression");
        String arg1Result = arg1.accept(visitor);
        assertTrue(arg1Result.contains("InfixExpression"), "Arg1 result should contain 'InfixExpression'");

        Expression arg2 = callExpr.getArguments().get(1);
        assertTrue(AstValidator.isIndexExpression(arg2), "Arg2 should be IndexExpression");
        String arg2Result = arg2.accept(visitor);
        assertTrue(arg2Result.contains("IndexExpression"), "Arg2 result should contain 'IndexExpression'");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 📍 POSITION TRACKING VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("📍 Position tracking across multiple lines")
    void testPositionTrackingMultipleLines() {
        String input = """
                let x = 5;
                let y = 10;
                let z = x + y;
                """;

        Program program = parseAndValidateProgram(input);
        assertEquals(3, program.getStatements().size());

        // Validate line numbers increase
        Statement stmt1 = program.getStatements().get(0);
        Statement stmt2 = program.getStatements().get(1);
        Statement stmt3 = program.getStatements().get(2);

        TokenPosition pos1 = stmt1.position();
        TokenPosition pos2 = stmt2.position();
        TokenPosition pos3 = stmt3.position();

        assertEquals(1, pos1.line(), "First statement should be on line 1");
        assertEquals(2, pos2.line(), "Second statement should be on line 2");
        assertEquals(3, pos3.line(), "Third statement should be on line 3");

        // All should start at beginning of line (or close to it)
        assertTrue(pos1.column() >= 0, "First statement column should be >= 0");
        assertTrue(pos2.column() >= 0, "Second statement column should be >= 0");
        assertTrue(pos3.column() >= 0, "Third statement column should be >= 0");
    }

    @Test
    @DisplayName("📍 Position tracking within complex expression")
    void testPositionTrackingComplexExpression() {
        String input = "let result = x + y * z;";
        Program program = parseAndValidateProgram(input);

        LetStatement letStmt = (LetStatement) program.getStatements().get(0);

        // Validate positions of all components
        TokenPosition letPos = letStmt.position();
        TokenPosition namePos = letStmt.getName().position();
        TokenPosition valuePos = letStmt.getValue().position();

        // All should be on line 1
        assertEquals(1, letPos.line(), "Let should be on line 1");
        assertEquals(1, namePos.line(), "Name should be on line 1");
        assertEquals(1, valuePos.line(), "Value should be on line 1");

        // Columns should progress logically (let < result < value)
        assertTrue(letPos.column() < namePos.column(), "Let should come before name");
        assertTrue(namePos.column() < valuePos.column(), "Name should come before value");

        // Validate positions within the expression tree
        InfixExpression addExpr = (InfixExpression) letStmt.getValue();
        Expression left = addExpr.getLeft();
        Expression right = addExpr.getRight();

        TokenPosition leftPos = left.position();
        TokenPosition rightPos = right.position();

        assertEquals(1, leftPos.line(), "Left operand should be on line 1");
        assertEquals(1, rightPos.line(), "Right operand should be on line 1");
        assertTrue(leftPos.column() < rightPos.column(), "Left should come before right");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 🔗 REFERENCE INTEGRITY VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("🔗 Function literal parameter references")
    void testFunctionLiteralParameterReferences() {
        String input = """
                let func = fn(a, b) {
                    return a + b;
                };
                """;

        Program program = parseAndValidateProgram(input);
        LetStatement letStmt = (LetStatement) program.getStatements().get(0);

        assertTrue(AstValidator.isFunctionLiteral(letStmt.getValue()), "Value should be FunctionLiteral");
        FunctionLiteral funcLit = (FunctionLiteral) letStmt.getValue();

        // Validate parameters
        assertEquals(2, funcLit.getParameters().size(), "Should have 2 parameters");

        Identifier param1 = funcLit.getParameters().get(0);
        Identifier param2 = funcLit.getParameters().get(1);

        assertEquals("a", param1.getValue(), "First parameter should be 'a'");
        assertEquals("b", param2.getValue(), "Second parameter should be 'b'");

        // Validate parameter positions
        assertNotNull(param1.position(), "Param1 should have position");
        assertNotNull(param2.position(), "Param2 should have position");
        assertTrue(param1.position().column() < param2.position().column(),
                "Param1 should come before param2");

        // Validate body structure
        BlockStatement body = funcLit.getBody();
        assertNotNull(body, "Function should have body");
        assertEquals(1, body.getStatements().size(), "Body should have 1 statement");

        assertTrue(AstValidator.isReturnStatement(body.getStatements().get(0)),
                "Body statement should be ReturnStatement");
        ReturnStatement returnStmt = (ReturnStatement) body.getStatements().get(0);

        // Validate return expression references parameters
        Expression returnValue = returnStmt.getReturnValue();
        assertTrue(AstValidator.isInfixExpression(returnValue), "Return value should be InfixExpression");

        InfixExpression addExpr = (InfixExpression) returnValue;
        assertEquals("+", addExpr.getOperator(), "Should be addition");

        assertTrue(AstValidator.isIdentifier(addExpr.getLeft()), "Left should be Identifier");
        assertTrue(AstValidator.isIdentifier(addExpr.getRight()), "Right should be Identifier");

        Identifier leftId = (Identifier) addExpr.getLeft();
        Identifier rightId = (Identifier) addExpr.getRight();

        assertEquals("a", leftId.getValue(), "Left identifier should be 'a'");
        assertEquals("b", rightId.getValue(), "Right identifier should be 'b'");
    }

    @Test
    @DisplayName("🔗 Array and hash literal element integrity")
    void testCollectionLiteralElementIntegrity() {
        String input = """
                let arr = [1, 2, 3];
                let hash = {"key1": "value1", "key2": "value2"};
                """;

        Program program = parseAndValidateProgram(input);
        assertEquals(2, program.getStatements().size());

        // Validate array literal
        LetStatement arrayStmt = (LetStatement) program.getStatements().get(0);
        assertTrue(AstValidator.isArrayLiteral(arrayStmt.getValue()), "Should be ArrayLiteral");

        ArrayLiteral arrayLit = (ArrayLiteral) arrayStmt.getValue();
        assertEquals(3, arrayLit.getElements().size(), "Array should have 3 elements");

        for (int i = 0; i < 3; i++) {
            Expression element = arrayLit.getElements().get(i);
            assertTrue(AstValidator.isIntegerLiteral(element), "Element should be IntegerLiteral");

            IntegerLiteral intElement = (IntegerLiteral) element;
            assertEquals(i + 1, intElement.getValue(), "Element value should be " + (i + 1));
            assertNotNull(element.position(), "Element should have position");
        }

        // Validate hash literal
        LetStatement hashStmt = (LetStatement) program.getStatements().get(1);
        assertTrue(AstValidator.isHashLiteral(hashStmt.getValue()), "Should be HashLiteral");

        HashLiteral hashLit = (HashLiteral) hashStmt.getValue();
        assertEquals(2, hashLit.getPairs().size(), "Hash should have 2 pairs");

        assertTrue(hashLit.getPairs().containsKey("key1"), "Should contain key1");
        assertTrue(hashLit.getPairs().containsKey("key2"), "Should contain key2");

        for (Expression value : hashLit.getPairs().values()) {
            assertTrue(AstValidator.isStringLiteral(value), "Hash value should be StringLiteral");
            assertNotNull(value.position(), "Hash value should have position");
            assertNotNull(value.toString(), "Hash value should have string representation");
        }
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 💾 IMMUTABILITY VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("💾 AST node immutability")
    void testASTNodeImmutability() {
        String input = """
                let numbers = [1, 2, 3];
                let result = numbers[0] + numbers[1];
                """;

        Program program = parseAndValidateProgram(input);

        // Test that collections returned from AST are immutable
        LetStatement arrayStmt = (LetStatement) program.getStatements().get(0);
        ArrayLiteral arrayLit = (ArrayLiteral) arrayStmt.getValue();

        // Getting elements should return unmodifiable list
        assertThrows(UnsupportedOperationException.class, () -> {
            arrayLit.getElements().add(new IntegerLiteral(null, 4));
        }, "Elements list should be unmodifiable");

        // Test program statements are unmodifiable
        assertThrows(UnsupportedOperationException.class, () -> {
            program.getStatements().add(new ExpressionStatement(null, null));
        }, "Statements list should be unmodifiable");

        // Test function parameters are unmodifiable
        String funcInput = "let f = fn(a, b) { return a + b; };";
        Program funcProgram = parseAndValidateProgram(funcInput);

        LetStatement funcStmt = (LetStatement) funcProgram.getStatements().get(0);
        FunctionLiteral funcLit = (FunctionLiteral) funcStmt.getValue();

        assertThrows(UnsupportedOperationException.class, () -> {
            funcLit.getParameters().add(new Identifier(null, "c"));
        }, "Parameters list should be unmodifiable");

        // Test block statement list is unmodifiable
        BlockStatement body = funcLit.getBody();
        assertThrows(UnsupportedOperationException.class, () -> {
            body.getStatements().add(new ExpressionStatement(null, null));
        }, "Block statements should be unmodifiable");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 📝 STRING REPRESENTATION VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("📝 String representation quality")
    void testStringRepresentationQuality() {
        String input = """
                let x = 5;
                const PI = 3;
                let add = fn(a, b) {
                    return a + b;
                };
                if (x > 0) {
                    return "positive";
                } else {
                    return "not positive";
                }
                """;

        Program program = parseAndValidateProgram(input);

        // Test program string representation
        String programString = program.toString();
        assertNotNull(programString, "Program string should not be null");
        assertFalse(programString.trim().isEmpty(), "Program string should not be empty");

        // Should contain key elements from source
        assertTrue(programString.contains("let"), "Should contain 'let'");
        assertTrue(programString.contains("const"), "Should contain 'const'");
        assertTrue(programString.contains("fn"), "Should contain 'fn'");
        assertTrue(programString.contains("if"), "Should contain 'if'");
        assertTrue(programString.contains("return"), "Should contain 'return'");

        // Test individual statement string representations
        for (Statement stmt : program.getStatements()) {
            String stmtString = stmt.toString();
            assertNotNull(stmtString, "Statement string should not be null");
            assertFalse(stmtString.trim().isEmpty(), "Statement string should not be empty");

            // String should be reasonably structured (not just garbage)
            assertTrue(stmtString.length() > 0, "Statement string should have content");
        }

        // Test specific statement string formats
        LetStatement letStmt = (LetStatement) program.getStatements().get(0);
        String letString = letStmt.toString();
        assertTrue(letString.contains("let"), "Let string should contain 'let'");
        assertTrue(letString.contains("x"), "Let string should contain variable name");
        assertTrue(letString.contains("5"), "Let string should contain value");
        assertTrue(letString.contains("="), "Let string should contain assignment");

        ConstStatement constStmt = (ConstStatement) program.getStatements().get(1);
        String constString = constStmt.toString();
        assertTrue(constString.contains("const"), "Const string should contain 'const'");
        assertTrue(constString.contains("PI"), "Const string should contain constant name");
    }

    // ═══════════════════════════════════════════════════════════════════════════
    // 🎯 TYPE SAFETY VALIDATION
    // ═══════════════════════════════════════════════════════════════════════════

    @Test
    @DisplayName("🎯 AST node type safety")
    void testASTNodeTypeSafety() {
        String input = """
                let x = 42;
                let y = "hello";
                let z = true;
                let arr = [1, 2, 3];
                let hash = {"key": "value"};
                """;

        Program program = parseAndValidateProgram(input);
        assertEquals(5, program.getStatements().size());

        // Validate integer literal type safety
        LetStatement intStmt = (LetStatement) program.getStatements().get(0);
        Expression intValue = intStmt.getValue();
        assertTrue(AstValidator.isIntegerLiteral(intValue), "Should be IntegerLiteral");
        assertFalse(AstValidator.isStringLiteral(intValue), "Should not be StringLiteral");
        assertFalse(AstValidator.isBooleanExpression(intValue), "Should not be BooleanExpression");

        // Validate string literal type safety
        LetStatement strStmt = (LetStatement) program.getStatements().get(1);
        Expression strValue = strStmt.getValue();
        assertTrue(AstValidator.isStringLiteral(strValue), "Should be StringLiteral");
        assertFalse(AstValidator.isIntegerLiteral(strValue), "Should not be IntegerLiteral");
        assertFalse(AstValidator.isBooleanExpression(strValue), "Should not be BooleanExpression");

        // Validate boolean expression type safety
        LetStatement boolStmt = (LetStatement) program.getStatements().get(2);
        Expression boolValue = boolStmt.getValue();
        assertTrue(AstValidator.isBooleanExpression(boolValue), "Should be BooleanExpression");
        assertFalse(AstValidator.isIntegerLiteral(boolValue), "Should not be IntegerLiteral");
        assertFalse(AstValidator.isStringLiteral(boolValue), "Should not be StringLiteral");

        // Validate array literal type safety
        LetStatement arrStmt = (LetStatement) program.getStatements().get(3);
        Expression arrValue = arrStmt.getValue();
        assertTrue(AstValidator.isArrayLiteral(arrValue), "Should be ArrayLiteral");
        assertFalse(AstValidator.isHashLiteral(arrValue), "Should not be HashLiteral");
        assertFalse(AstValidator.isIntegerLiteral(arrValue), "Should not be IntegerLiteral");

        // Validate hash literal type safety
        LetStatement hashStmt = (LetStatement) program.getStatements().get(4);
        Expression hashValue = hashStmt.getValue();
        assertTrue(AstValidator.isHashLiteral(hashValue), "Should be HashLiteral");
        assertFalse(AstValidator.isArrayLiteral(hashValue), "Should not be ArrayLiteral");
        assertFalse(AstValidator.isIntegerLiteral(hashValue), "Should not be IntegerLiteral");
    }

    @Test
    @DisplayName("🎯 Expression vs Statement type safety")
    void testExpressionStatementTypeSafety() {
        String input = """
                let x = 5;
                x + 2;
                return x;
                """;

        Program program = parseAndValidateProgram(input);
        assertEquals(3, program.getStatements().size());

        // First should be let statement
        Statement stmt1 = program.getStatements().get(0);
        assertTrue(AstValidator.isLetStatement(stmt1), "Should be LetStatement");
        assertFalse(AstValidator.isReturnStatement(stmt1), "Should not be ReturnStatement");
        assertFalse(AstValidator.isExpressionStatement(stmt1), "Should not be ExpressionStatement");

        // Second should be expression statement
        Statement stmt2 = program.getStatements().get(1);
        assertTrue(AstValidator.isExpressionStatement(stmt2), "Should be ExpressionStatement");
        assertFalse(AstValidator.isLetStatement(stmt2), "Should not be LetStatement");
        assertFalse(AstValidator.isReturnStatement(stmt2), "Should not be ReturnStatement");

        // Third should be return statement
        Statement stmt3 = program.getStatements().get(2);
        assertTrue(AstValidator.isReturnStatement(stmt3), "Should be ReturnStatement");
        assertFalse(AstValidator.isLetStatement(stmt3), "Should not be LetStatement");
        assertFalse(AstValidator.isExpressionStatement(stmt3), "Should not be ExpressionStatement");

        // Validate expression within expression statement
        ExpressionStatement exprStmt = (ExpressionStatement) stmt2;
        Expression expr = exprStmt.getExpression();
        assertTrue(AstValidator.isInfixExpression(expr), "Should be InfixExpression");
        assertFalse(AstValidator.isIdentifier(expr), "Should not be Identifier");
        assertFalse(AstValidator.isIntegerLiteral(expr), "Should not be IntegerLiteral");
    }
}